### 가상 메모리(Vertual Memory)  
실행하고자 하는 프로그램의 일부만 메모리에 적재해서 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.  

## 페이징(Paging)  
연속 메모리 할당 방식에서 외부 단편화의 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.  
만약 메모리와 프로세스를 일정한 단위로 자르고, 메모리에 불연속적으로 할당할 수 있다면 외부 단편화가 발생하지 않을 수 있다.  
페이징은 프로세스의 논리 주소 공간을 페이지(Page) 단위로 자르고, 메모리 물리 주소 공간을 페이지와 동일한 크기의 단위인 프레임(Frame)으로 자른다.  
페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.  
![프레임과 페이징](/images/paging.webp)  
페이징에서도 스와핑이 가능하다. 프로세스 전체가 아닌 페이지 단위로 스왑 아웃/스왑 인 된다.  
메모리에 적재될 필요 없는 페이지들은 보조 기억 장치로 스왑 아웃되고, 실행에 필요한 페이지들은 메모리로 스왑 인 된다.  
![페이지 인 아웃](/images/swapinout.png)  
한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요는 없다는 말과 같다. 실행에 필요한 일부 페이지만 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조 기억 장치에 남겨둘 수 있다.  
이러한 방식으로 물리 메모리보다 큰 프로세스 실행이 가능하다.  

## 페이지 테이블(Page Table)  
프로세스가 메모리에 불연속적으로 배치되면 CPU는 다음에 싱행할 명령어 위치 찾는 것이 어려워진다.  
그래서 페이징 시스템은 프로세스가 실제 메모리 내의 주소인 물리 주소에 불연속적으로 배치되더라도  
CPU가 바라보는 주소인 논리 주소에는 연속적으로 배치되도록 하는 방법이다.  
페이지 테이블은 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려준다.  
물리 주소상에서는 프로세스들이 분산되어 보여도 페이지 테이블을 통해 CPU 입장에서 보는 논리 주소는 연속적으로 보일 수 있다.  
프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 순차적으로 실행하면 되는 것이다.  

## 페이지 테이블 베이스 레지스터(PTBR; Page Table Base Register)  
각 프로세스의 페이지 테이블이 적재된 주소.  
페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다는 단점이 있다.  
메모리에 있는 페이지 테이블을 보기위해 한 번, 그렇게 알게 된 프레임에 접근하기 위해 총 두번의 메모리 접근을 하게 된다.  

## Translation Lookaside Buffer; TLB  
페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장하는 방법.  
TLB는 페이지 테이블의 캐시이기 때문에 페이지 테이블의 일부 내용을 저장한다.  
참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 저장한다.  
각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다. 프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변한다.  

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트라고 한다.  
이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없다. 그래서 메모리 접근을 한 번만 하면 된다.  
만약 페이지 번호가 TLB에 없을 경우 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근할 수 밖에 없다.  
이것을 TLB 미스라고 한다.  

## 페이징에서의 주소 변환  
하나의 페이지, 프레임은 여러 주소를 포괄하기 때문에 특정 주소에 접근하려면 두 정보가 필요하다.  
- 어떤 페이지나 프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지나 프레임으로부터 얼마나 떨어져 있는지
  
페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위(Offset)로 이루어져 있다.  
페이지 번호는 접근하고자 하는 페이지 번호이다.  
페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있다.  
변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보이다.  
논리주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소 <프레임 번호, 변위>로 변환된다.  

## 페이지 테이블 엔트리(Page Table Entry; PTE)  
페이지 테이블의 각각의 행들.  
- 유효 비트(Valid Bit)  
  현재 해당 페이지에 접근 가능한지 여부를 알려주는 비트. 페이지 테이블 엔트리에서 프레임 번호 다음으로 중요한 정보.
  현재 페이지가 메모리에 적재되었는지, 보조 기억 장치에 있느니 알려주는 비트이다.  
  페이지에 메모리가 적재되어 있으면 1, 페이지에 메모리가 적재되어 있지 않는다면 유효 비트는 0이 된다.  
  만약 CPU가 유효비트가 0인 메모리에 적재되어있지 않는 페이지로 접근하려고 하면 페이지 폴트(Page Fault)라는 예외가 발생한다.  
  CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.  
  1. CPU는 기존의 작업 내용을 백업한다.  
  2. 페이지 폴트 루틴을 실행한다.  
  3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져오고 유효 비트를 1로 변경한다.  
  4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근할 수 있게 된다.  
    
- 보호 비트(Protection Bit)  
  페이지 보로 기능을 위해 존재하느 비트. 해당 페이지가 R/W이 모두 되는지 아니면 ReadOnly인 페이지인지 알려주는 비트이다.  
  0일 경우 읽기만 가능한 페이지이고, 1일 경우 읽고 쓰기가 모두 가능한 페이지 이다.  
  읽기 전용인 페이지에 쓰기를 시도하면 운영체제에서 그것을 막는다.  
  보호 비트에는 읽기를 나타내는 `r`, 쓰기를 나타내는 `w`, 실행을 나타내는 `x`로 표기한다.  
  만약 보호 비트가 110인 페이지가 있다면 그 페이지는 읽고 쓰기는 되지만 실행은 되지 않는 페이지인 것이다.    

- 참조 비트(Reference Bit)  
  CPU가 이 페이지로 접근한 적이 있는지 여부 확인용 비트이다.  
  적재 이후 CPU가 읽거나 쓴 페이지는 1, 적재 이후 그런적 없는 페이지는 0으로 유지된다.  

- 수정 비트(Modified Bit)  
  해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려주는 비트. 더티 비트(Dirty Bit)라고 하기도 한다.  
  이 비트가 1 이면 변경된 적이 있고 0 이면 변경된 적 없는 페이지 이다.  
  수정 비트는 페이지가 메모리에서 사라질 때 보조 기억 장치에서 쓰기 작업을 할지 말지 판단하기 위한 비트이다.  
  결국 같은 내용이기 때문에 한번도 수정된 적이 없는 페이지가 스왑 아웃될 경우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 된다.  

## 페이징의 이점  
대표적으로 프로세스 사이에 페이지를 공유할 수 있다는 점이다. 쓰기 시 복사(Copy On Write)가 대표적이다.  
fork 시스템 호출을 통해 부모 프로세스의 복사본이 자식 프로세스로서 만들어진다.  
프로세스 사이에 기본적으로 자원을 공유하지 않는다는 프로세스의 전통적인 개념으로부터 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 전혀 다른 메모리 공간에 생성된다.  
부모 프로세스의 메모리 영역이 다른 영역에 자식 프로세스로서 복제되고, 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킨다.  
이러한 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다.  
하지만 쓰기 시 복사는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킨다.  
부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있게 되는 것이다.  
만약 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 읽기 작업만 한다면 이 상태가 지속된다.  
부모 프로세스나 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 시작하면 그 순간 해당 페이지가 별도의 공간으로 복제된다.  
각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키는데 이것을 쓰기 시 복사라고 한다.  

## 계층적 페이징(Hierarchical Paging)  
프로세스의 크기가 커지면 자연스럽게 프로세스 테이블의 크기도 커지기 때문에 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 메모리 낭비다.  
계층적 페이징은 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 방법이다.  
페이지 테이블을 페이징해서 여러 단계의 페이지를 두는 방식이다. 다단계 페이지 테이블(Multilevel Page Table)이라고도 한다.  
프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에서 페이지 테이블을 하나 더 두고 잘린 페이지의 테이블의 페이지들을 가리키게 하는 방식이다.  
페이지 테이블을 계층적으로 구성하면 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어진다.  
피이지 테이블 중 몇개는 보조 기억 장치에 있어도 무방하며, 나중에 해당 페이지 테이블을 참조할 때면 그 때 메모리에 적재하면 된다.  

계층적 페이징을 사용하면 CPU가 발생하는 논리 주소도 달라진다.  
바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한 페이지 테이블 엔트리를 가리키고, 안쪽 페이지 번호는 페이지 테이블의 페이지 번호를 가리킨다.  
주소 변환은 아래와 같이 이루어진다.  
1. 바깥 페이지 번호를 통해 페이지 테이블의 페이지 찾기
2. 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더해 물리 주소 얻기
![페이지 테이블](/images/pagetable.png)  
페이지 테이블의 계층이 늘어난다고 좋은것은 아니다.
만약 페이지 폴트가 일어날 경우 메모리 참조 횟수가 많아져 항상 유리한 것은 아니다.
