## 요구 페이징(Demand Paging)  
프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법.  
1. CPU가 특정 페이지에 접근하는 명령어를 실행.
2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1인 경우) CPU는 페이지가 적재된 프레임에 접근.
3. 해당 페이지가 현재 메모리에 없을 경우(유효 비트가 0일 경우) CPU는 페이지 폴트가 발생.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정.
5. 다시 CPU가 특정 페이지에 접근하는 명령어를 실행.

## 순수 요구 페이징(Pure Demand Paging)  
아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 하면,  
프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 발생하게 된다.  
실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다.  

## 페이지 교체 알고리즘  
요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 된다.  
그러면 당장에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조 기억 장치로 내보내야 한다.  
어떤 페이지를 내보낼지 결정하는 페이지 교체 알고리즘이다.  
보통 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘이라고 평가한다.  
페이지 폴트가 일어나면 보조 기억 장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문이다.  
`한 페이지 교체 알고리즘을 선택했더니 페이지 폴트가 자주 발생했다`=`보조 기억 장치로 내쫓을 페이지를 잘못 골랐다`  
이기 때문에 컴퓨터의 성능을 저해하는 나쁜 알고리즘인 것이다.  

페이지 교채 알고리즘을 이해하려면 페이지 폴트 횟수를 알아야 하며 그것은 페이지 참조열(Page Reference String)을 통해 알 수 있다.  
페이지 참조열은 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미한다.  
CPU가 `2223555337`순서로 왔다면 연속된 페이지를 생략한 페이지 참조열은 `23537`이 된다.  
연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위로는 페이지 폴트를 발생시키지 않기 때문이다.  
CPU가 특정 페이지에 열번 연속으로 접근한다고 한 번 접근하는 것보다 페이지 폴트가 많이 발생하지 않는 것처럼.  
어차피 페이지 폴트가 일어나지 않을 연속된 페이지에 대한 참조는 고려하지 않는 것이다.  

### FIFO 페이지 교체 알고리즘(First In First Out Page Replacement Algorithm)  
메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식.  
적재된 페이지 순서대로 교체하는 알고리즘.  

### 최적 페이지 교체 알고리즘(Optimal Page Replacement Algorithm)  
CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘. 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.  
가장 낮은 페이지 폴트율을 보장하는 알고리즘이다. 하지만 실제 구현이 어렵다.  

### LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement Algorithm)  
가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘.  

## 스레싱(Thrashing)  
프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요해 성능이 저해되는 문제.  
빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 것이다.  
![스레싱 그래프](/images/thrashing.png)  
세로축인 CPU 이용률을 통해 CPU가 일하는 정도를 파악할 수 있다. 가로축인 멀티 프로그래밍의 정도를 통해 메모리에 올라온 프로세스의 수를 알 수 있다.  
메모리에서 동시에 실행되는 프로세스의 수를 멀티프로그래밍의 정도(Degree Of Mulitprogramming)이라고 한다.  
멀티 프로그래밍의 정도가 높으면 현재 메모리에는 많은 프로세스가 동시에 실행중인 것이다.  

## 프레임 할당  
스레싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다.  
- 균등 할당(Equal Allocation)  
  모든 프로세스에 균등하게 프레임을 제공하는 방식이다.  
  프로세스의 크기는 모두 다른데 같은 프레임 개수를 적용하는 것은 비효율적이다.
  
- 비례 할당(Proportional Allocation)  
  프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스의 크기가 작으면 조금 할당하는 프로세스 크기에 비례하는 방식.  
  하지만 프로세스가 얼마나 많은 프레임이 필요한지는 프로세스를 실행해 봐야 알 수있는 문제로 이 방법도 만능은 아니다.

프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방법도 있다.  
아래 두 방식은 프로세스의 실행을 보고 할당할 프레임 수를 결정한다는 점에서 동적 할당 방식이라고도 한다.  
- 작업 집합 기반 모델(Working Set Model)  
  프로세스가 일정 기간 동안 참조한 페이지 집합을 기억해 빈번한 페이지 교체를 방지.  
  CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당한다면 페이지 교체는 빈번하지 않을 것이다.
  실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 작업 집합(Working Set)이라고 한다.
  CPU가 과거에 주로 참조한 페이지를 작업 집합에 포함시킨다면 운영체제는 작업 집합의 크기만큼만 프레임을 할당해주면 된다.
  
- 페이지 폴트 빈도(Page Fault Frequency)  
  두 개의 가정이 필요하다.  
  1. 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 적은 프레임을 갖고 있다.  
  2. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 많은 프레임을 갖고 있다.  
  ![페이지 폴트 그래프](/images/pagefalutgraph.png)
  만약 페이지 폴트율이 upper bound보다 높으면 그 프로세스는 너무 적은 프레임을 갖는 것이므로 프레임을 더 할당해주면 된다.  
  반대의 상황이면 반대로 하면 된다.  
  페이지 폴트 기반 프레임 할당 방식은 페이지 폴트율에 상한선과 하한선을 정하고 이 범위 안에서만 프레임을 할당하는 방법이다.  
