## 명령어 파이프라인
명령어 처리 과정을 클럭 단위로 나누어 보면
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)  

같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다. 이런 식으로 명령어를 처리하기 위해 명령어 파이프 라인에 명령어들을 넣고 동시에 처리하는 기법을 명령어 파이프라인이라고 한다.
파이프라이닝이 성능 향상을 가져오긴 하지만 항상 그런 것은 아니고 실패하는 경우도 있다. 이런 상황을 파이프라인 위험(Pipeline Hazard)이라고 한다.  
- 데이터 위험(Data Hazard)
  명령어 사이 데이터 의존성에 의해 발생함.
  > 명령어 1 : R1 <- R2 + R3  
  > 명령어 2 : R4 <- R1 + R5
    
  명령어 2는 명령어 1의 데이터에 의존적인 상태이므로 두 명령어를 동시에 실행시킬 수 없다. 이러한 오류를 데이터 위험이라고 한다.
- 제어 위험(Control Hazard)  
  분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생.
  프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신된다.
  하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생기면
   명령어 파이프라인에 미리 가지고 와서 처리중이었던 명령어들은 아무 쓸모가 없어진다. 이러한 것을 제어 위험이라고 한다.
  
- 구조적 위험(Structure Hazard)
  명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터등과 같은 CPU부품을 사용하려고 할때 발생. 자원 위험(Resource Hazard)라고도 한다.
  
## 슈퍼스칼라
CPU 내부에 여러개의 명령어 파이프라인을 포함한 구조.

## 비순차적 명령어 처리 기법(OoOE, Out-of-Order Execution)
명령어들을 순차적으로 처리하는 것이 아니라 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행해 명령어 파이프라인이 멈추는 것을 방지하는 기법. 

