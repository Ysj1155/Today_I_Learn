## 뮤테스 락(Mutex Lock; Mutual Exclusion Lock)  
동시에 접근하면 안되는 자원에 동시 접근을 막는 도구. 상호 배제를 위한 동기화 도구.  
뮤텍스 락의 단순하게 하나의 전역 변수와 두개의 함수로 구현할 수 있다.  
- 프로세스들이 공유하는 전역 변수 lock
  
- acquire 함수
  프로세스가 임계 구역에 진입하기 전에 호출하는 함수. 만약 임계 구역이 잠겨있다면 임계 구역이 열릴 때까지(lock이 false될 때 까지) 임계 구역을 반복적으로 확인.
  임계 구역이 열려있다면 임게구역을 잠그는(lock을 true로 바꾸는) 함수.
  
- release 함수
  임계 구역에서 작업이 끝나고 호출하는 함수. 현재 잠긴 임계 구역을 열어주는(locl을 false로 바꾸는) 함수.

```python
acquire() {
    while (lock == true)      /* 만약 임계 구역이 잠겨 있다면 */
        ;                     /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
    lock == ture;             /* 만약 임계 구역이 잠겨있지 않다면 임계 구역 잠금 */
}

release() {
    lock = false;             /* 임계 구역 작업이 끝났으니 잠금 해제 */
}
```
acquire와 release 함수를 아래와 같이 임계 구역 전후로 호출해서 하나의 프로세스만 임계 구역에 진입할 수 있다.  
```python
acquire();                   // 자물쇠 잠겨있는지 확인, 아니라면 잠그고 들어가기
// 임계구역                   // 임계 구역에서 작업 진행
release();                   // 자물쇠 반환
```
아래와 같이 뮤택스로 구현 가능.  
```python
acquire();
// '총합' 변수 접근
release();
```
프로세스는  
- 락을 획득할 수 없다면(임계 구역에 진입할 수 없다면) 무작정 기다리고
- 락을 획득할 수 있다면(임계 구역에 진입할 수 있다면) 임계구역을 잠그고 임계 구역에서 작업 진행
- 임계 구역을 빠져나올 땐 다시 임계 구역의 잠금을 해제
하면서 임계구역 보호 가능하다.
임계 구역이 잠겨있는 경우 프로세스는 반복적으로 lock을 확인한다.
```python
while (lock == ture)        /* 만약 임계 구역이 잠겨 있다면 */
      ;                     /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
```
이런 대기 방식을 바쁜 대기(Busy Wait)이라고 한다.  

## 세마포(Semaphore)  
뮤텍스 락보다는 조금 더 일반화된 방식의 동기화 도구. 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구.  
하나의 변수와 두개의 함수로 단순하게 구현이 가능하다.  
- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역변수 S
- 임계 구역에 들어가도 좋은지, 기다려야 하는지 알려주는 wait 함수
- 임계 구역 앞에서 기다리는 프로세스에 허락 신호를 주는 signal 함수
```python
wait() {
    while (S <= 0)    /* 만약 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 */
    ;                 /* 사용할 수 있는 자원이 있는지 반복적으로 확인 */
    S--;              /* 임계 구역에 진입할 수 있는 프로세스의 개수가 하나 이상이면 S를 1 감소시키고 임계 구역에 진입 */
}
signal() {
    S++               /* 임계 구역에서의 작업을 마치고 S를 1 증가 */
```
사용할 수 있는 공유 자원이 없는 경우 프로세스는 무작정 무한히 반복하며 S를 확인해야 한다.  
이렇게 바쁜 대기를 반복하면 CPU 주기가 낭비된다. 그래서 세마포는 다른 좋은 방법을 사용한다.  
```python
wait() {
    S--;
    if ( S < 0 ) {
        remove this process to Queue;    /* 해당 프로세스 PCB를 대기 큐에 삽입 */
        sleep();                         /* 대기 상태 */
    }
}
signal() {
    S++
    if ( S <= 0 ) {
        remove a process p from Queue    /* 대기 큐에 있는 프로세스 p를 제거 */
        wakeup(p)                        /* 프로세스 p를 대기 상태에서 준비 상태로 만든다 */
```

## 모니터(Monitor)  
공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리. 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근해야 한다.  
모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유 자원을 이용하도록 한다.  
즉, 모니터는 공유 자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 해서 상호 배제를 위한 동기화를 제공한다.  

모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다. 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위한 모니터는 조건 변수(Condition Variable)을 사용한다.   
조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 쓰는 특별한 변수다.   
모니터는 아래와 같은 프로세스 실행 순선 제어를 위한 동기화를 제공한다.  
1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때는 wait을 통해 실행을 중단한다.
2. 특정 프로세스가 실행될 조건이 충족되면 signal을 통해 실행을 재개한다.
